name: 'Deploy CloudFormation Stack'
description: 'Deploy AWS CloudFormation stacks with parameter support and real-time monitoring'

inputs:
  stack-name:
    description: 'Name of the CloudFormation stack to deploy'
    required: true
  template-path:
    description: 'Path to the CloudFormation template file'
    required: true
  deployment-parameters:
    description: 'CloudFormation parameters as JSON string'
    required: false
    default: 'null'
  cloudformation-tags:
    description: 'CloudFormation tags as JSON string (key-value pairs)'
    required: false
    default: 'null'

runs:
  using: 'composite'
  steps:
    - name: Validate System Dependencies
      shell: bash
      run: |
        echo "=== System Dependencies Validation ==="
        
        # Check AWS CLI availability
        if ! command -v aws >/dev/null 2>&1; then
          echo "‚ùå Error: AWS CLI is not installed or not available in PATH"
          echo "Please ensure AWS CLI is installed and configured before using this action."
          echo "See: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html"
          exit 127
        fi
        
        # Check jq availability for parameter processing
        if ! command -v jq >/dev/null 2>&1; then
          echo "‚ùå Error: jq is not installed or not available in PATH"
          echo "jq is required for JSON parameter processing."
          echo "Please ensure jq is installed in the runner environment."
          exit 127
        fi
        
        # Verify AWS CLI can be executed
        if ! aws --version >/dev/null 2>&1; then
          echo "‚ùå Error: AWS CLI is installed but cannot be executed"
          echo "There may be a configuration or permission issue."
          exit 126
        fi
        
        echo "‚úÖ System dependencies verified (AWS CLI, jq)"
        
        # Verify AWS credentials are configured
        echo "Verifying AWS credentials..."
        if ! aws sts get-caller-identity >/dev/null 2>&1; then
          echo "‚ùå Error: AWS credentials are not configured or invalid"
          echo "Please ensure AWS credentials are properly configured for this action."
          echo "This can be done through:"
          echo "  - IAM roles (recommended for GitHub Actions)"
          echo "  - Environment variables (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)"
          echo "  - AWS credential files"
          echo "See: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html"
          exit 1
        fi
        
        # Get and display AWS identity for verification
        AWS_IDENTITY=$(aws sts get-caller-identity --output text --query 'Arn' 2>/dev/null || echo "Unknown")
        echo "‚úÖ AWS credentials verified (Identity: $AWS_IDENTITY)"

    - name: Validate Inputs and Template
      shell: bash
      env:
        DEPLOYMENT_STACK_NAME: ${{ inputs.stack-name }}
        DEPLOYMENT_TEMPLATE_PATH: ${{ inputs.template-path }}
        DEPLOYMENT_PARAMETERS: ${{ inputs.deployment-parameters }}
        DEPLOYMENT_TAGS: ${{ inputs.cloudformation-tags }}
      run: |
        echo "=== Input Validation ==="
        
        # Validate required inputs are provided
        if [ -z "$DEPLOYMENT_STACK_NAME" ] || [ "$DEPLOYMENT_STACK_NAME" = "null" ]; then
          echo "‚ùå Error: stack-name is required but not provided"
          exit 1
        fi
        
        if [ -z "$DEPLOYMENT_TEMPLATE_PATH" ] || [ "$DEPLOYMENT_TEMPLATE_PATH" = "null" ]; then
          echo "‚ùå Error: template-path is required but not provided"
          exit 1
        fi
        
        # Validate template file existence
        if [ ! -f "$DEPLOYMENT_TEMPLATE_PATH" ]; then
          echo "‚ùå Error: CloudFormation template file not found at path: $DEPLOYMENT_TEMPLATE_PATH"
          echo "Please ensure the template file exists and the path is correct."
          exit 1
        fi
        
        # Validate template file is readable
        if [ ! -r "$DEPLOYMENT_TEMPLATE_PATH" ]; then
          echo "‚ùå Error: CloudFormation template file is not readable: $DEPLOYMENT_TEMPLATE_PATH"
          echo "Please check file permissions."
          exit 1
        fi
        
        # Handle null/empty parameters
        if [ "$DEPLOYMENT_PARAMETERS" = "null" ] || [ -z "$DEPLOYMENT_PARAMETERS" ]; then
          DEPLOYMENT_PARAMETERS=""
        fi
        
        # Handle null/empty tags
        if [ "$DEPLOYMENT_TAGS" = "null" ] || [ -z "$DEPLOYMENT_TAGS" ]; then
          DEPLOYMENT_TAGS=""
        fi
        
        # Display validated configuration
        echo "‚úÖ Input validation completed successfully"
        echo "Stack Name: $DEPLOYMENT_STACK_NAME"
        echo "Template Path: $DEPLOYMENT_TEMPLATE_PATH"
        echo "Template File: $(basename "$DEPLOYMENT_TEMPLATE_PATH")"
        echo "Template Size: $(wc -c < "$DEPLOYMENT_TEMPLATE_PATH") bytes"
        
        if [ -n "$DEPLOYMENT_PARAMETERS" ] && [ "$DEPLOYMENT_PARAMETERS" != "" ]; then
          echo "Parameters: Provided ($(echo "$DEPLOYMENT_PARAMETERS" | wc -c) characters)"
        else
          echo "Parameters: None provided"
        fi
        
        if [ -n "$DEPLOYMENT_TAGS" ] && [ "$DEPLOYMENT_TAGS" != "" ] && [ "$DEPLOYMENT_TAGS" != "null" ]; then
          echo "Tags: Provided ($(echo "$DEPLOYMENT_TAGS" | wc -c) characters)"
        else
          echo "Tags: None provided"
        fi
        
        # Save validated inputs to environment files for next steps
        echo "$DEPLOYMENT_STACK_NAME" > /tmp/stack-name
        echo "$DEPLOYMENT_TEMPLATE_PATH" > /tmp/template-path
        echo "$DEPLOYMENT_PARAMETERS" > /tmp/deployment-parameters
        echo "$DEPLOYMENT_TAGS" > /tmp/deployment-tags
        
        # Template validation step
        echo ""
        echo "=== Template Validation ==="
        echo "Validating CloudFormation template..."
        VALIDATION_OUTPUT=$(aws cloudformation validate-template --template-body "file://$DEPLOYMENT_TEMPLATE_PATH" 2>&1)
        VALIDATION_EXIT_CODE=$?
        
        if [ $VALIDATION_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Error: CloudFormation template validation failed (Exit Code: $VALIDATION_EXIT_CODE)"
          echo "Template: $DEPLOYMENT_TEMPLATE_PATH"
          echo ""
          echo "AWS CLI validation output:"
          echo "$VALIDATION_OUTPUT"
          echo ""
          echo "Please fix the template errors and try again."
          exit $VALIDATION_EXIT_CODE
        fi
        echo "‚úÖ Template validation successful"

    - name: Process Parameters
      shell: bash
      env:
        DEPLOYMENT_TAGS_INPUT: ${{ inputs.cloudformation-tags }}
      run: |
        echo "=== Parameter Processing ==="
        
        # Load inputs from previous step
        DEPLOYMENT_STACK_NAME=$(cat /tmp/stack-name)
        DEPLOYMENT_TEMPLATE_PATH=$(cat /tmp/template-path)
        DEPLOYMENT_PARAMETERS=$(cat /tmp/deployment-parameters)
        
        # Try to load from temp file first, but fallback to direct input if empty
        DEPLOYMENT_TAGS_FROM_FILE=$(cat /tmp/deployment-tags | tr -d '\n\r')
        
        # Use direct input if file is empty
        if [ -z "$DEPLOYMENT_TAGS_FROM_FILE" ] && [ -n "$DEPLOYMENT_TAGS_INPUT" ] && [ "$DEPLOYMENT_TAGS_INPUT" != "null" ]; then
          DEPLOYMENT_TAGS="$DEPLOYMENT_TAGS_INPUT"
        else
          DEPLOYMENT_TAGS="$DEPLOYMENT_TAGS_FROM_FILE"
        fi
        
        PARAMETER_OVERRIDES=""
        
        if [ -n "$DEPLOYMENT_PARAMETERS" ] && [ "$DEPLOYMENT_PARAMETERS" != "" ] && [ "$DEPLOYMENT_PARAMETERS" != "null" ]; then
          echo "Processing deployment parameters..."
          
          # PARAMETER PROCESSING LOGIC:
          # This section handles two different JSON parameter formats and converts them
          # to AWS CLI parameter overrides format (key=value pairs)
          
          # Step 1: Validate JSON format with detailed error reporting
          # Use jq to parse and validate the JSON structure
          JSON_VALIDATION_OUTPUT=$(echo "$DEPLOYMENT_PARAMETERS" | jq . 2>&1)
          JSON_VALIDATION_EXIT_CODE=$?
          
          if [ $JSON_VALIDATION_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Error: deployment-parameters must be valid JSON (Exit Code: $JSON_VALIDATION_EXIT_CODE)"
            # Security: Avoid logging raw parameters - only show length for debugging
            PARAM_LENGTH=$(echo "$DEPLOYMENT_PARAMETERS" | wc -c | tr -d ' ')
            echo "Provided parameters: [HIDDEN - $PARAM_LENGTH characters for security]"
            echo ""
            echo "JSON validation error:"
            echo "$JSON_VALIDATION_OUTPUT"
            echo ""
            echo "Please ensure your parameters are properly formatted JSON."
            exit $JSON_VALIDATION_EXIT_CODE
          fi
          
          # Step 2: Detect parameter format using jq type checking
          # The action supports two formats:
          # 1. CloudFormation native: [{"ParameterName": "key", "ParameterValue": "value"}]
          # 2. Simple key-value: {"key": "value"}
          
          # Check if it's an array (CloudFormation native format)
          if echo "$DEPLOYMENT_PARAMETERS" | jq -e 'type == "array"' > /dev/null 2>&1; then
            echo "Detected CloudFormation native parameter format (array)"
            
            # Validate array structure: each element must be an object with required keys
            # This ensures the array contains proper CloudFormation parameter objects
            if ! echo "$DEPLOYMENT_PARAMETERS" | jq -e 'all(type == "object" and has("ParameterName") and has("ParameterValue"))' > /dev/null 2>&1; then
              echo "‚ùå Error: CloudFormation parameter array must contain objects with 'ParameterName' and 'ParameterValue' keys"
              echo "Expected format: [{\"ParameterName\": \"key\", \"ParameterValue\": \"value\"}]"
              exit 1
            fi
            
            # Convert CloudFormation native format to AWS CLI parameter overrides
            # Transform: [{"ParameterName": "Env", "ParameterValue": "prod"}] -> "Env=prod"
            PARAMETER_CONVERSION_OUTPUT=$(echo "$DEPLOYMENT_PARAMETERS" | jq -r '.[] | "\(.ParameterName)=\(.ParameterValue)"' 2>&1)
            PARAMETER_CONVERSION_EXIT_CODE=$?
            
            if [ $PARAMETER_CONVERSION_EXIT_CODE -ne 0 ]; then
              echo "‚ùå Error: Failed to convert CloudFormation parameters (Exit Code: $PARAMETER_CONVERSION_EXIT_CODE)"
              echo "Conversion error: $PARAMETER_CONVERSION_OUTPUT"
              exit $PARAMETER_CONVERSION_EXIT_CODE
            fi
            
            # Join multiple parameters with spaces and remove trailing space
            PARAMETER_OVERRIDES=$(echo "$PARAMETER_CONVERSION_OUTPUT" | tr '\n' ' ' | sed 's/ $//')
            
          # Check if it's an object (simple key-value format)
          elif echo "$DEPLOYMENT_PARAMETERS" | jq -e 'type == "object"' > /dev/null 2>&1; then
            echo "Detected simple key-value parameter format (object)"
            
            # Convert simple key-value format to AWS CLI parameter overrides
            # Transform: {"Environment": "prod", "Type": "t3.micro"} -> "Environment=prod Type=t3.micro"
            # Uses jq's to_entries to convert object to key-value pairs
            PARAMETER_CONVERSION_OUTPUT=$(echo "$DEPLOYMENT_PARAMETERS" | jq -r 'to_entries[] | "\(.key)=\(.value)"' 2>&1)
            PARAMETER_CONVERSION_EXIT_CODE=$?
            
            if [ $PARAMETER_CONVERSION_EXIT_CODE -ne 0 ]; then
              echo "‚ùå Error: Failed to convert key-value parameters (Exit Code: $PARAMETER_CONVERSION_EXIT_CODE)"
              echo "Conversion error: $PARAMETER_CONVERSION_OUTPUT"
              exit $PARAMETER_CONVERSION_EXIT_CODE
            fi
            
            # Join multiple parameters with spaces and remove trailing space
            PARAMETER_OVERRIDES=$(echo "$PARAMETER_CONVERSION_OUTPUT" | tr '\n' ' ' | sed 's/ $//')
            
          else
            echo "‚ùå Error: deployment-parameters must be either an array of CloudFormation parameter objects or a simple key-value object"
            echo "CloudFormation format: [{\"ParameterName\": \"key\", \"ParameterValue\": \"value\"}]"
            echo "Simple format: {\"key\": \"value\"}"
            exit 1
          fi
          
          # Validate that we have parameter overrides
          if [ -z "$PARAMETER_OVERRIDES" ]; then
            echo "‚ö†Ô∏è  Warning: No parameters extracted from provided JSON"
            echo "Parameters will be empty for deployment"
          else
            echo "‚úÖ Parameter processing completed successfully"
            # Count parameters for security logging (avoid exposing sensitive values)
            PARAM_COUNT=$(echo "$PARAMETER_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
            echo "Parameter overrides: $PARAM_COUNT parameter(s) processed (values hidden for security)"
          fi
          
        else
          echo "No parameters provided - deploying stack without parameter overrides"
        fi
        
        # Save parameter overrides for next step
        echo "$PARAMETER_OVERRIDES" > /tmp/parameter-overrides
        echo "Parameter processing completed."
        
        # Process CloudFormation tags
        TAG_OVERRIDES=""
        
        if [ -n "$DEPLOYMENT_TAGS" ] && [ "$DEPLOYMENT_TAGS" != "" ] && [ "$DEPLOYMENT_TAGS" != "null" ] && [ "$DEPLOYMENT_TAGS" != "\"null\"" ]; then
          echo "Processing deployment tags..."
          
          # Validate JSON format for tags
          TAG_VALIDATION_OUTPUT=$(echo "$DEPLOYMENT_TAGS" | jq . 2>&1)
          TAG_VALIDATION_EXIT_CODE=$?
          
          if [ $TAG_VALIDATION_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Error: cloudformation-tags must be valid JSON (Exit Code: $TAG_VALIDATION_EXIT_CODE)"
            TAGS_LENGTH=$(echo "$DEPLOYMENT_TAGS" | wc -c | tr -d ' ')
            echo "Provided tags: [HIDDEN - $TAGS_LENGTH characters for security]"
            echo ""
            echo "JSON validation error:"
            echo "$TAG_VALIDATION_OUTPUT"
            echo ""
            echo "Please ensure your tags are properly formatted JSON."
            exit $TAG_VALIDATION_EXIT_CODE
          fi
          
          # Check if it's an array (CloudFormation native tag format)
          if echo "$DEPLOYMENT_TAGS" | jq -e 'type == "array"' > /dev/null 2>&1; then
            echo "Detected CloudFormation native tag format (array)"
            
            # Validate array contains objects with Key and Value
            if ! echo "$DEPLOYMENT_TAGS" | jq -e 'all(type == "object" and has("Key") and has("Value"))' > /dev/null 2>&1; then
              echo "‚ùå Error: CloudFormation tag array must contain objects with 'Key' and 'Value' keys"
              echo "Expected format: [{\"Key\": \"key\", \"Value\": \"value\"}]"
              exit 1
            fi
            
            # Convert CloudFormation native format to tag overrides
            # Transform: [{"Key": "Environment", "Value": "prod"}] -> "Environment=\"prod\""
            # Always quote values to handle spaces and special characters
            TAG_CONVERSION_OUTPUT=$(echo "$DEPLOYMENT_TAGS" | jq -r '.[] | "\(.Key)=\"\(.Value)\""' 2>&1)
            TAG_CONVERSION_EXIT_CODE=$?
            
            if [ $TAG_CONVERSION_EXIT_CODE -ne 0 ]; then
              echo "‚ùå Error: Failed to convert CloudFormation tags (Exit Code: $TAG_CONVERSION_EXIT_CODE)"
              echo "Conversion error: $TAG_CONVERSION_OUTPUT"
              exit $TAG_CONVERSION_EXIT_CODE
            fi
            
            # Join multiple tags with spaces and remove trailing space
            TAG_OVERRIDES=$(echo "$TAG_CONVERSION_OUTPUT" | tr '\n' ' ' | sed 's/ $//')
            
          # Check if it's an object (simple key-value format for tags)
          elif echo "$DEPLOYMENT_TAGS" | jq -e 'type == "object"' > /dev/null 2>&1; then
            echo "Detected key-value tag format (object)"
            
            # Convert key-value format to tag overrides
            # Transform: {"Environment": "prod", "Project": "myapp"} -> "Environment=\"prod\" Project=\"myapp\""
            # Always quote values to handle spaces and special characters
            TAG_CONVERSION_OUTPUT=$(echo "$DEPLOYMENT_TAGS" | jq -r 'to_entries[] | "\(.key)=\"\(.value)\""' 2>&1)
            TAG_CONVERSION_EXIT_CODE=$?
            
            if [ $TAG_CONVERSION_EXIT_CODE -ne 0 ]; then
              echo "‚ùå Error: Failed to convert tags (Exit Code: $TAG_CONVERSION_EXIT_CODE)"
              echo "Conversion error: $TAG_CONVERSION_OUTPUT"
              exit $TAG_CONVERSION_EXIT_CODE
            fi
            
            # Join multiple tags with spaces and remove trailing space
            TAG_OVERRIDES=$(echo "$TAG_CONVERSION_OUTPUT" | tr '\n' ' ' | sed 's/ $//')
            
          else
            echo "‚ùå Error: cloudformation-tags must be either an array of CloudFormation tag objects or a simple key-value object"
            echo "CloudFormation format: [{\"Key\": \"key\", \"Value\": \"value\"}]"
            echo "Simple format: {\"key\": \"value\"}"
            exit 1
          fi
          
          # Validate that we have tag overrides
          if [ -z "$TAG_OVERRIDES" ]; then
            echo "‚ö†Ô∏è  Warning: No tags extracted from provided JSON"
            echo "Tags will be empty for deployment"
          else
            echo "‚úÖ Tag processing completed successfully"
            # Count tags for logging (avoid exposing sensitive values)
            TAG_COUNT=$(echo "$TAG_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
            echo "Tag overrides: $TAG_COUNT tag(s) processed (values hidden for security)"
          fi
          
        else
          echo "No tags provided - deploying stack without tags"
        fi
        
        # Save tag overrides for next step
        echo "$TAG_OVERRIDES" > /tmp/tag-overrides
        echo "Tag processing completed."

    - name: Deploy CloudFormation Stack
      shell: bash
      run: |
        echo "=== CloudFormation Deployment ==="
        
        # Load inputs from previous steps
        DEPLOYMENT_STACK_NAME=$(cat /tmp/stack-name)
        DEPLOYMENT_TEMPLATE_PATH=$(cat /tmp/template-path)
        PARAMETER_OVERRIDES=$(cat /tmp/parameter-overrides)
        TAG_OVERRIDES=$(cat /tmp/tag-overrides | tr -d '\n\r')
        
        # Prepare deployment command
        DEPLOY_CMD="aws cloudformation deploy --template-file \"$DEPLOYMENT_TEMPLATE_PATH\" --stack-name \"$DEPLOYMENT_STACK_NAME\" --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM --no-fail-on-empty-changeset --disable-rollback"
        
        if [ -n "$PARAMETER_OVERRIDES" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --parameter-overrides $PARAMETER_OVERRIDES"
        fi
        
        if [ -n "$TAG_OVERRIDES" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --tags $TAG_OVERRIDES"
        fi
        
        echo "Starting CloudFormation deployment..."
        echo "Stack Name: $DEPLOYMENT_STACK_NAME"
        echo "Template: $DEPLOYMENT_TEMPLATE_PATH"
        if [ -n "$PARAMETER_OVERRIDES" ]; then
          # Count parameters for security logging (avoid exposing sensitive values)
          PARAM_COUNT=$(echo "$PARAMETER_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
          echo "Parameters: $PARAM_COUNT parameter(s) configured (values hidden for security)"
        else
          echo "Parameters: None"
        fi
        if [ -n "$TAG_OVERRIDES" ]; then
          # Count tags for security logging (avoid exposing sensitive values)
          TAG_COUNT=$(echo "$TAG_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
          echo "Tags: $TAG_COUNT tag(s) configured (values hidden for security)"
        else
          echo "Tags: None"
        fi
        echo "Rollback: Disabled on failure"
        echo ""
        
        # Log deployment command without exposing parameter and tag values for security
        DEPLOY_CMD_SAFE=$(echo "$DEPLOY_CMD" | sed 's/--parameter-overrides [^[:space:]]*/--parameter-overrides [HIDDEN_FOR_SECURITY]/' | sed 's/--tags [^[:space:]]*/--tags [HIDDEN_FOR_SECURITY]/')
        echo "Executing: $DEPLOY_CMD_SAFE"
        
        # Execute the command directly instead of in background
        # This ensures we get the proper exit code and output
        echo "Starting CloudFormation deployment..."
        eval "$DEPLOY_CMD"
        DEPLOY_EXIT_CODE=$?
        
        # Save the exit code for the next step
        echo "$DEPLOY_EXIT_CODE" > /tmp/deploy-exit-code
        
        # If deployment failed, show error details
        if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
          echo "‚ùå CloudFormation deployment failed with exit code: $DEPLOY_EXIT_CODE"
          exit $DEPLOY_EXIT_CODE
        fi
        
        echo "‚úÖ CloudFormation deployment completed successfully!"

    - name: Display Stack Information
      shell: bash
      run: |
        echo "=== Stack Information ==="
        
        # Load deployment info
        DEPLOYMENT_STACK_NAME=$(cat /tmp/stack-name)
        DEPLOY_EXIT_CODE=$(cat /tmp/deploy-exit-code)
        
        # If deployment failed, exit with the same code
        if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
          echo "‚ùå CloudFormation deployment failed with exit code: $DEPLOY_EXIT_CODE"
          exit $DEPLOY_EXIT_CODE
        fi
        
        # Display stack events with only essential attributes for better readability
        echo "Recent Stack Events:"
        aws cloudformation describe-stack-events \
          --stack-name "$DEPLOYMENT_STACK_NAME" \
          --query "StackEvents[:10].[Timestamp,LogicalResourceId,ResourceType,ResourceStatus,ResourceStatusReason || '-']" \
          --output table || echo "‚ö†Ô∏è Unable to retrieve stack events"
        
        # Display stack outputs in a clean, readable format
        echo ""
        echo "=== Stack Outputs ==="
        STACK_OUTPUTS=$(aws cloudformation describe-stacks \
          --stack-name "$DEPLOYMENT_STACK_NAME" \
          --query "Stacks[0].Outputs" \
          --output json 2>/dev/null)
          
        if [ $? -eq 0 ] && [ "$STACK_OUTPUTS" != "null" ] && [ "$STACK_OUTPUTS" != "[]" ]; then
          # Format outputs in a clean, readable way
          echo "$STACK_OUTPUTS" | jq -r '.[] | "‚Ä¢ \(.OutputKey): \(.OutputValue)\(if .Description then "\n  Description: \(.Description)" else "" end)"'
        else
          echo "‚ö†Ô∏è No outputs found for stack"
        fi
        
        # Display stack status
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name "$DEPLOYMENT_STACK_NAME" \
          --query "Stacks[0].StackStatus" \
          --output text)
        
        echo ""
        echo "Final Stack Status: $STACK_STATUS"
        
        # Verify successful status
        case "$STACK_STATUS" in
          "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_COMPLETE_CLEANUP_IN_PROGRESS")
            echo "‚úÖ Stack deployment successful!"
            ;;
          *)
            echo "‚ö†Ô∏è Stack is in state: $STACK_STATUS"
            echo "This may indicate an issue with the deployment."
            exit 1
            ;;
        esac

    - name: Generate GitHub Actions Step Summary
      shell: bash
      run: |
        # Load deployment info from previous steps
        DEPLOYMENT_STACK_NAME=$(cat /tmp/stack-name)
        DEPLOYMENT_TEMPLATE_PATH=$(cat /tmp/template-path)
        PARAMETER_OVERRIDES=$(cat /tmp/parameter-overrides)
        TAG_OVERRIDES=$(cat /tmp/tag-overrides | tr -d '\n\r')
        DEPLOY_EXIT_CODE=$(cat /tmp/deploy-exit-code)
        
        # Get stack information
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$DEPLOYMENT_STACK_NAME" --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "UNKNOWN")
        
        # Get stack events for timing calculation - use simpler approach
        echo "Retrieving stack events for timing calculation..."
        
        # Get the first CREATE_IN_PROGRESS or UPDATE_IN_PROGRESS event for the stack (start time)
        START_EVENT=$(aws cloudformation describe-stack-events \
          --stack-name "$DEPLOYMENT_STACK_NAME" \
          --query "StackEvents[?ResourceType=='AWS::CloudFormation::Stack' && (ResourceStatus=='CREATE_IN_PROGRESS' || ResourceStatus=='UPDATE_IN_PROGRESS')] | [-1]" \
          --output json 2>/dev/null)
        
        # Get the most recent CREATE_COMPLETE, UPDATE_COMPLETE, or final status event for the stack (end time)
        END_EVENT=$(aws cloudformation describe-stack-events \
          --stack-name "$DEPLOYMENT_STACK_NAME" \
          --query "StackEvents[?ResourceType=='AWS::CloudFormation::Stack' && (ResourceStatus=='CREATE_COMPLETE' || ResourceStatus=='UPDATE_COMPLETE' || ResourceStatus=='CREATE_FAILED' || ResourceStatus=='UPDATE_FAILED')] | [0]" \
          --output json 2>/dev/null)
        
        # Extract timestamps using jq
        if [ "$START_EVENT" != "null" ] && [ "$START_EVENT" != "" ]; then
          START_TIMESTAMP=$(echo "$START_EVENT" | jq -r '.Timestamp // empty' 2>/dev/null)
        else
          START_TIMESTAMP=""
        fi
        
        if [ "$END_EVENT" != "null" ] && [ "$END_EVENT" != "" ]; then
          END_TIMESTAMP=$(echo "$END_EVENT" | jq -r '.Timestamp // empty' 2>/dev/null)
        else
          END_TIMESTAMP=""
        fi
        
        # Calculate duration and format timestamps
        if [ -n "$START_TIMESTAMP" ] && [ -n "$END_TIMESTAMP" ]; then
          # Convert ISO timestamps to epoch (works on both Linux and macOS)
          if command -v gdate >/dev/null 2>&1; then
            # macOS with GNU coreutils
            START_EPOCH=$(gdate -d "$START_TIMESTAMP" +%s 2>/dev/null)
            END_EPOCH=$(gdate -d "$END_TIMESTAMP" +%s 2>/dev/null)
            FORMATTED_START_TIME=$(gdate -d "$START_TIMESTAMP" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null)
            FORMATTED_END_TIME=$(gdate -d "$END_TIMESTAMP" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null)
          else
            # Linux or macOS with BSD date
            START_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${START_TIMESTAMP%.*}" +%s 2>/dev/null || date -d "$START_TIMESTAMP" +%s 2>/dev/null)
            END_EPOCH=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${END_TIMESTAMP%.*}" +%s 2>/dev/null || date -d "$END_TIMESTAMP" +%s 2>/dev/null)
            FORMATTED_START_TIME=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${START_TIMESTAMP%.*}" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || date -d "$START_TIMESTAMP" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null)
            FORMATTED_END_TIME=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${END_TIMESTAMP%.*}" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || date -d "$END_TIMESTAMP" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null)
          fi
          
          # Calculate duration if we have valid epochs
          if [ -n "$START_EPOCH" ] && [ -n "$END_EPOCH" ] && [ "$START_EPOCH" -gt 0 ] && [ "$END_EPOCH" -gt 0 ]; then
            DURATION_SECONDS=$((END_EPOCH - START_EPOCH))
            
            # Format duration
            if [ $DURATION_SECONDS -lt 60 ]; then
              DURATION="${DURATION_SECONDS}s"
            elif [ $DURATION_SECONDS -lt 3600 ]; then
              DURATION_MINUTES=$((DURATION_SECONDS / 60))
              DURATION_REMAINING=$((DURATION_SECONDS % 60))
              DURATION="${DURATION_MINUTES}m ${DURATION_REMAINING}s"
            else
              DURATION_HOURS=$((DURATION_SECONDS / 3600))
              DURATION_REMAINING=$((DURATION_SECONDS % 3600))
              DURATION_MINUTES=$((DURATION_REMAINING / 60))
              DURATION_SECONDS_FINAL=$((DURATION_REMAINING % 60))
              DURATION="${DURATION_HOURS}h ${DURATION_MINUTES}m ${DURATION_SECONDS_FINAL}s"
            fi
          else
            DURATION="Unknown"
            FORMATTED_START_TIME="Unknown"
            FORMATTED_END_TIME="Unknown"
          fi
        else
          DURATION="Unknown"
          FORMATTED_START_TIME="Unknown"
          FORMATTED_END_TIME="Unknown"
        fi
        
        # Fallback: if we still don't have timing info, try to get basic stack info
        if [ "$FORMATTED_START_TIME" = "Unknown" ]; then
          STACK_CREATION_TIME=$(aws cloudformation describe-stacks --stack-name "$DEPLOYMENT_STACK_NAME" --query "Stacks[0].CreationTime" --output text 2>/dev/null)
          if [ -n "$STACK_CREATION_TIME" ] && [ "$STACK_CREATION_TIME" != "None" ]; then
            if command -v gdate >/dev/null 2>&1; then
              FORMATTED_START_TIME=$(gdate -d "$STACK_CREATION_TIME" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || echo "Unknown")
            else
              FORMATTED_START_TIME=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${STACK_CREATION_TIME%.*}" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || date -d "$STACK_CREATION_TIME" -u +"%Y-%m-%d %H:%M:%S UTC" 2>/dev/null || echo "Unknown")
            fi
          fi
        fi
        
        if [ "$FORMATTED_END_TIME" = "Unknown" ]; then
          FORMATTED_END_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
        fi
        
        # Determine success/failure status
        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          case "$STACK_STATUS" in
            "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_COMPLETE_CLEANUP_IN_PROGRESS")
              OPERATION_RESULT="‚úÖ success"
              SUMMARY_STATUS="‚úÖ **Stack creation success**"
              RESULT_MESSAGE="The CloudFormation stack has been successfully created."
              ;;
            *)
              OPERATION_RESULT="‚ö†Ô∏è warning"
              SUMMARY_STATUS="‚ö†Ô∏è **Stack creation completed with warnings**"
              RESULT_MESSAGE="The CloudFormation stack deployment completed but is in state: $STACK_STATUS"
              ;;
          esac
        else
          OPERATION_RESULT="‚ùå failed"
          SUMMARY_STATUS="‚ùå **Stack creation failed**"
          RESULT_MESSAGE="The CloudFormation stack deployment failed with exit code: $DEPLOY_EXIT_CODE"
        fi
        
        # Generate the GitHub Actions Step Summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # CloudFormation Stack Creation Report
        
        ## Summary
        $SUMMARY_STATUS
        
        ## Details
        | Property | Value |
        |----------|-------|
        | Stack Name | \`$DEPLOYMENT_STACK_NAME\` |
        | Final Status | \`$STACK_STATUS\` |
        | Operation Result | $OPERATION_RESULT |
        | Duration | $DURATION |
        
        ## Timing Information
        - **Start Time:** $FORMATTED_START_TIME
        - **End Time:** $FORMATTED_END_TIME
        - **Total Duration:** $DURATION
        
        ## Result
        $RESULT_MESSAGE
        EOF
        
        echo "‚úÖ GitHub Actions Step Summary generated successfully"

    - name: Display Final Results and Stack Information
      shell: bash
      run: |
        # Load deployment info from previous steps
        DEPLOYMENT_STACK_NAME=$(cat /tmp/stack-name)
        DEPLOYMENT_TEMPLATE_PATH=$(cat /tmp/template-path)
        PARAMETER_OVERRIDES=$(cat /tmp/parameter-overrides)
        TAG_OVERRIDES=$(cat /tmp/tag-overrides | tr -d '\n\r')
        DEPLOY_EXIT_CODE=$(cat /tmp/deploy-exit-code)
        
        # Display deployment summary
        echo ""
        echo "=== Deployment Summary ==="
        echo "üìã Deployment Configuration:"
        echo "Stack Name: $DEPLOYMENT_STACK_NAME"
        echo "Template File: $DEPLOYMENT_TEMPLATE_PATH"
        echo "Template Size: $(wc -c < "$DEPLOYMENT_TEMPLATE_PATH") bytes"
        
        if [ -n "$PARAMETER_OVERRIDES" ]; then
          # Count parameters for security logging (avoid exposing sensitive values)
          PARAM_COUNT=$(echo "$PARAMETER_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
          PARAM_NAMES=$(echo "$PARAMETER_OVERRIDES" | sed 's/=.*//g' | tr '\n' ', ')
          echo "Parameters: $PARAM_COUNT parameter(s) configured"
          echo "Parameter Names: $PARAM_NAMES"
        else
          echo "Parameters: None"
        fi
        
        if [ -n "$TAG_OVERRIDES" ]; then
          # Count tags for security logging (avoid exposing sensitive values)
          TAG_COUNT=$(echo "$TAG_OVERRIDES" | tr ' ' '\n' | wc -l | tr -d ' ')
          TAG_NAMES=$(echo "$TAG_OVERRIDES" | sed 's/=.*//g' | tr '\n' ', ')
          echo "Tags: $TAG_COUNT tag(s) configured"
          echo "Tag Names: $TAG_NAMES"
        else
          echo "Tags: None"
        fi
        
        # Get execution time
        START_TIME=$(date +%s)
        
        # Verify stack status with error handling
        echo ""
        echo "üìà Execution Results:"
        echo "Deployment Exit Code: $DEPLOY_EXIT_CODE"
        
        # Determine final status
        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          # Get stack status
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$DEPLOYMENT_STACK_NAME" --query "Stacks[0].StackStatus" --output text 2>/dev/null || echo "UNKNOWN")
          
          # Calculate execution time
          END_TIME=$(date +%s)
          EXECUTION_TIME=$((END_TIME - START_TIME))
          echo "Final Stack Status: $STACK_STATUS"
          echo "Execution Time: ${EXECUTION_TIME}s"
          
          echo "‚úÖ SUCCESS: CloudFormation deployment completed successfully!"
          echo "Stack is in state: $STACK_STATUS"
          
          # Exit with success
          exit 0
        else
          # Calculate execution time
          END_TIME=$(date +%s)
          EXECUTION_TIME=$((END_TIME - START_TIME))
          echo "Final Action Exit Code: $DEPLOY_EXIT_CODE"
          echo "Execution Time: ${EXECUTION_TIME}s"
          
          echo "üí• FAILURE: CloudFormation deployment failed!"
          echo "‚ùå What went wrong:"
          echo "‚Ä¢ Deployment process exited with code $DEPLOY_EXIT_CODE"
          echo "‚Ä¢ Check the error analysis and troubleshooting guidance above"
          echo "‚Ä¢ Review stack events for specific failure details"
          
          # Exit with the same error code
          exit $DEPLOY_EXIT_CODE
        fi